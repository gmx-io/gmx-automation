/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace OracleUtils {
  export type SetPricesParamsStruct = {
    tokens: PromiseOrValue<string>[];
    providers: PromiseOrValue<string>[];
    data: PromiseOrValue<BytesLike>[];
  };

  export type SetPricesParamsStructOutput = [string[], string[], string[]] & {
    tokens: string[];
    providers: string[];
    data: string[];
  };
}

export interface TimelockConfigInterface extends utils.Interface {
  functions: {
    "MAX_TIMELOCK_DELAY()": FunctionFragment;
    "cancelAction(bytes32)": FunctionFragment;
    "dataStore()": FunctionFragment;
    "eventEmitter()": FunctionFragment;
    "execute(address,bytes)": FunctionFragment;
    "executeBatch(address[],uint256[],bytes[])": FunctionFragment;
    "executeWithOraclePrice(address,bytes,(address[],address[],bytes[]))": FunctionFragment;
    "getHash(address,bytes)": FunctionFragment;
    "getHashBatch(address[],bytes[],uint256[])": FunctionFragment;
    "increaseTimelockDelay(uint256)": FunctionFragment;
    "multicall(bytes[])": FunctionFragment;
    "oracleStore()": FunctionFragment;
    "revokeRole(address,bytes32)": FunctionFragment;
    "roleStore()": FunctionFragment;
    "signalAddOracleSigner(address)": FunctionFragment;
    "signalGrantRole(address,bytes32)": FunctionFragment;
    "signalRemoveOracleSigner(address)": FunctionFragment;
    "signalRevokeRole(address,bytes32)": FunctionFragment;
    "signalSetAtomicOracleProvider(address,bool)": FunctionFragment;
    "signalSetDataStream(address,bytes32,uint256,uint256)": FunctionFragment;
    "signalSetFeeReceiver(address)": FunctionFragment;
    "signalSetHoldingAddress(address)": FunctionFragment;
    "signalSetOracleProviderEnabled(address,bool)": FunctionFragment;
    "signalSetOracleProviderForToken(address,address)": FunctionFragment;
    "signalSetPriceFeed(address,address,uint256,uint256,uint256)": FunctionFragment;
    "signalWithdrawFromPositionImpactPool(address,address,uint256)": FunctionFragment;
    "signalWithdrawTokens(address,address,address,uint256)": FunctionFragment;
    "timelockController()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "MAX_TIMELOCK_DELAY"
      | "cancelAction"
      | "dataStore"
      | "eventEmitter"
      | "execute"
      | "executeBatch"
      | "executeWithOraclePrice"
      | "getHash"
      | "getHashBatch"
      | "increaseTimelockDelay"
      | "multicall"
      | "oracleStore"
      | "revokeRole"
      | "roleStore"
      | "signalAddOracleSigner"
      | "signalGrantRole"
      | "signalRemoveOracleSigner"
      | "signalRevokeRole"
      | "signalSetAtomicOracleProvider"
      | "signalSetDataStream"
      | "signalSetFeeReceiver"
      | "signalSetHoldingAddress"
      | "signalSetOracleProviderEnabled"
      | "signalSetOracleProviderForToken"
      | "signalSetPriceFeed"
      | "signalWithdrawFromPositionImpactPool"
      | "signalWithdrawTokens"
      | "timelockController"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "MAX_TIMELOCK_DELAY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancelAction",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "dataStore", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "eventEmitter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "execute",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "executeBatch",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "executeWithOraclePrice",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      OracleUtils.SetPricesParamsStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getHash",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getHashBatch",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "increaseTimelockDelay",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "oracleStore",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "revokeRole",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "roleStore", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "signalAddOracleSigner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "signalGrantRole",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "signalRemoveOracleSigner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "signalRevokeRole",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "signalSetAtomicOracleProvider",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "signalSetDataStream",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "signalSetFeeReceiver",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "signalSetHoldingAddress",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "signalSetOracleProviderEnabled",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "signalSetOracleProviderForToken",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "signalSetPriceFeed",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "signalWithdrawFromPositionImpactPool",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "signalWithdrawTokens",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "timelockController",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "MAX_TIMELOCK_DELAY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelAction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "dataStore", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "eventEmitter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeWithOraclePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getHash", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getHashBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "increaseTimelockDelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "oracleStore",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "revokeRole", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "roleStore", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "signalAddOracleSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalGrantRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalRemoveOracleSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalRevokeRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalSetAtomicOracleProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalSetDataStream",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalSetFeeReceiver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalSetHoldingAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalSetOracleProviderEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalSetOracleProviderForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalSetPriceFeed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalWithdrawFromPositionImpactPool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signalWithdrawTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "timelockController",
    data: BytesLike
  ): Result;

  events: {};
}

export interface TimelockConfig extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TimelockConfigInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    MAX_TIMELOCK_DELAY(overrides?: CallOverrides): Promise<[BigNumber]>;

    cancelAction(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    dataStore(overrides?: CallOverrides): Promise<[string]>;

    eventEmitter(overrides?: CallOverrides): Promise<[string]>;

    execute(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executeBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      payloads: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executeWithOraclePrice(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      oracleParams: OracleUtils.SetPricesParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getHash(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getHashBatch(
      targets: PromiseOrValue<string>[],
      payloads: PromiseOrValue<BytesLike>[],
      values: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[string]>;

    increaseTimelockDelay(
      _timelockDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oracleStore(overrides?: CallOverrides): Promise<[string]>;

    revokeRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    roleStore(overrides?: CallOverrides): Promise<[string]>;

    signalAddOracleSigner(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalGrantRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalRemoveOracleSigner(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalRevokeRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalSetAtomicOracleProvider(
      provider: PromiseOrValue<string>,
      value: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalSetDataStream(
      token: PromiseOrValue<string>,
      feedId: PromiseOrValue<BytesLike>,
      dataStreamMultiplier: PromiseOrValue<BigNumberish>,
      dataStreamSpreadReductionFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalSetFeeReceiver(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalSetHoldingAddress(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalSetOracleProviderEnabled(
      provider: PromiseOrValue<string>,
      value: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalSetOracleProviderForToken(
      token: PromiseOrValue<string>,
      provider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalSetPriceFeed(
      token: PromiseOrValue<string>,
      priceFeed: PromiseOrValue<string>,
      priceFeedMultiplier: PromiseOrValue<BigNumberish>,
      priceFeedHeartbeatDuration: PromiseOrValue<BigNumberish>,
      stablePrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalWithdrawFromPositionImpactPool(
      market: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signalWithdrawTokens(
      target: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    timelockController(overrides?: CallOverrides): Promise<[string]>;
  };

  MAX_TIMELOCK_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

  cancelAction(
    id: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  dataStore(overrides?: CallOverrides): Promise<string>;

  eventEmitter(overrides?: CallOverrides): Promise<string>;

  execute(
    target: PromiseOrValue<string>,
    payload: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executeBatch(
    targets: PromiseOrValue<string>[],
    values: PromiseOrValue<BigNumberish>[],
    payloads: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executeWithOraclePrice(
    target: PromiseOrValue<string>,
    payload: PromiseOrValue<BytesLike>,
    oracleParams: OracleUtils.SetPricesParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getHash(
    target: PromiseOrValue<string>,
    payload: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  getHashBatch(
    targets: PromiseOrValue<string>[],
    payloads: PromiseOrValue<BytesLike>[],
    values: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<string>;

  increaseTimelockDelay(
    _timelockDelay: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  multicall(
    data: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oracleStore(overrides?: CallOverrides): Promise<string>;

  revokeRole(
    account: PromiseOrValue<string>,
    roleKey: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  roleStore(overrides?: CallOverrides): Promise<string>;

  signalAddOracleSigner(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalGrantRole(
    account: PromiseOrValue<string>,
    roleKey: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalRemoveOracleSigner(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalRevokeRole(
    account: PromiseOrValue<string>,
    roleKey: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalSetAtomicOracleProvider(
    provider: PromiseOrValue<string>,
    value: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalSetDataStream(
    token: PromiseOrValue<string>,
    feedId: PromiseOrValue<BytesLike>,
    dataStreamMultiplier: PromiseOrValue<BigNumberish>,
    dataStreamSpreadReductionFactor: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalSetFeeReceiver(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalSetHoldingAddress(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalSetOracleProviderEnabled(
    provider: PromiseOrValue<string>,
    value: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalSetOracleProviderForToken(
    token: PromiseOrValue<string>,
    provider: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalSetPriceFeed(
    token: PromiseOrValue<string>,
    priceFeed: PromiseOrValue<string>,
    priceFeedMultiplier: PromiseOrValue<BigNumberish>,
    priceFeedHeartbeatDuration: PromiseOrValue<BigNumberish>,
    stablePrice: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalWithdrawFromPositionImpactPool(
    market: PromiseOrValue<string>,
    receiver: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signalWithdrawTokens(
    target: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    receiver: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  timelockController(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    MAX_TIMELOCK_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    cancelAction(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    dataStore(overrides?: CallOverrides): Promise<string>;

    eventEmitter(overrides?: CallOverrides): Promise<string>;

    execute(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    executeBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      payloads: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    executeWithOraclePrice(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      oracleParams: OracleUtils.SetPricesParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    getHash(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    getHashBatch(
      targets: PromiseOrValue<string>[],
      payloads: PromiseOrValue<BytesLike>[],
      values: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<string>;

    increaseTimelockDelay(
      _timelockDelay: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    oracleStore(overrides?: CallOverrides): Promise<string>;

    revokeRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    roleStore(overrides?: CallOverrides): Promise<string>;

    signalAddOracleSigner(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalGrantRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalRemoveOracleSigner(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalRevokeRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalSetAtomicOracleProvider(
      provider: PromiseOrValue<string>,
      value: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalSetDataStream(
      token: PromiseOrValue<string>,
      feedId: PromiseOrValue<BytesLike>,
      dataStreamMultiplier: PromiseOrValue<BigNumberish>,
      dataStreamSpreadReductionFactor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalSetFeeReceiver(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalSetHoldingAddress(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalSetOracleProviderEnabled(
      provider: PromiseOrValue<string>,
      value: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalSetOracleProviderForToken(
      token: PromiseOrValue<string>,
      provider: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalSetPriceFeed(
      token: PromiseOrValue<string>,
      priceFeed: PromiseOrValue<string>,
      priceFeedMultiplier: PromiseOrValue<BigNumberish>,
      priceFeedHeartbeatDuration: PromiseOrValue<BigNumberish>,
      stablePrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalWithdrawFromPositionImpactPool(
      market: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    signalWithdrawTokens(
      target: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    timelockController(overrides?: CallOverrides): Promise<string>;
  };

  filters: {};

  estimateGas: {
    MAX_TIMELOCK_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    cancelAction(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    dataStore(overrides?: CallOverrides): Promise<BigNumber>;

    eventEmitter(overrides?: CallOverrides): Promise<BigNumber>;

    execute(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executeBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      payloads: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executeWithOraclePrice(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      oracleParams: OracleUtils.SetPricesParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getHash(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getHashBatch(
      targets: PromiseOrValue<string>[],
      payloads: PromiseOrValue<BytesLike>[],
      values: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    increaseTimelockDelay(
      _timelockDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oracleStore(overrides?: CallOverrides): Promise<BigNumber>;

    revokeRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    roleStore(overrides?: CallOverrides): Promise<BigNumber>;

    signalAddOracleSigner(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalGrantRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalRemoveOracleSigner(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalRevokeRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalSetAtomicOracleProvider(
      provider: PromiseOrValue<string>,
      value: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalSetDataStream(
      token: PromiseOrValue<string>,
      feedId: PromiseOrValue<BytesLike>,
      dataStreamMultiplier: PromiseOrValue<BigNumberish>,
      dataStreamSpreadReductionFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalSetFeeReceiver(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalSetHoldingAddress(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalSetOracleProviderEnabled(
      provider: PromiseOrValue<string>,
      value: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalSetOracleProviderForToken(
      token: PromiseOrValue<string>,
      provider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalSetPriceFeed(
      token: PromiseOrValue<string>,
      priceFeed: PromiseOrValue<string>,
      priceFeedMultiplier: PromiseOrValue<BigNumberish>,
      priceFeedHeartbeatDuration: PromiseOrValue<BigNumberish>,
      stablePrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalWithdrawFromPositionImpactPool(
      market: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signalWithdrawTokens(
      target: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    timelockController(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    MAX_TIMELOCK_DELAY(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancelAction(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    dataStore(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    eventEmitter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    execute(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executeBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      payloads: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executeWithOraclePrice(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      oracleParams: OracleUtils.SetPricesParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getHash(
      target: PromiseOrValue<string>,
      payload: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getHashBatch(
      targets: PromiseOrValue<string>[],
      payloads: PromiseOrValue<BytesLike>[],
      values: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    increaseTimelockDelay(
      _timelockDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oracleStore(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    revokeRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    roleStore(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    signalAddOracleSigner(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalGrantRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalRemoveOracleSigner(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalRevokeRole(
      account: PromiseOrValue<string>,
      roleKey: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalSetAtomicOracleProvider(
      provider: PromiseOrValue<string>,
      value: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalSetDataStream(
      token: PromiseOrValue<string>,
      feedId: PromiseOrValue<BytesLike>,
      dataStreamMultiplier: PromiseOrValue<BigNumberish>,
      dataStreamSpreadReductionFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalSetFeeReceiver(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalSetHoldingAddress(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalSetOracleProviderEnabled(
      provider: PromiseOrValue<string>,
      value: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalSetOracleProviderForToken(
      token: PromiseOrValue<string>,
      provider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalSetPriceFeed(
      token: PromiseOrValue<string>,
      priceFeed: PromiseOrValue<string>,
      priceFeedMultiplier: PromiseOrValue<BigNumberish>,
      priceFeedHeartbeatDuration: PromiseOrValue<BigNumberish>,
      stablePrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalWithdrawFromPositionImpactPool(
      market: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signalWithdrawTokens(
      target: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    timelockController(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
